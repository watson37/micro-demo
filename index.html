<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Supply & Demand Demo (Fixed Axes)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:18px;color:#111}
    h1{font-size:20px;margin-bottom:6px}
    .row{display:flex;gap:18px;align-items:flex-start}
    .controls{width:320px}
    label{display:block;margin:10px 0 6px;font-weight:600}
    input[type=range]{width:100%}
    canvas{background:#fbfbfb;border:1px solid #e6e6e6;border-radius:8px}
    .info{margin-top:12px}
    .stat{margin:6px 0}
    .muted{color:#666;font-size:13px}
    .small{color:#666;font-size:12px}
    .pcRow{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:8px}
    .pill{display:inline-block;padding:4px 8px;border-radius:999px;border:1px solid #e6e6e6;background:#fff;font-size:12px}
    .btn{display:inline-block;padding:8px 10px;border-radius:8px;background:#0366d6;color:white;text-decoration:none;border:0;cursor:pointer}
    .rowTop{display:flex;justify-content:space-between;align-items:center}
  </style>
</head>
<body>
  <div class="rowTop">
    <div>
      <h1>Interactive Supply & Demand Demo</h1>
      <p class="muted">Axes fixed (0–100). Curves stop drawing when they exit the visible price range. Use Reset to return to defaults.</p>
    </div>
    <div>
      <button id="resetBtn" class="btn">↺ Reset</button>
    </div>
  </div>

  <div class="row" style="margin-top:12px;">
    <div class="controls">
      <label>Demand shift (right = higher demand)</label>
      <input id="dIntercept" type="range" min="-8" max="8" step="0.5" value="0">
      <div class="small">This moves demand up/down without rescaling the axes.</div>

      <label>Supply shift (right = higher supply)</label>
      <input id="sIntercept" type="range" min="-8" max="8" step="0.5" value="0">

      <label>Demand steepness (0 = flat / perfectly elastic)</label>
      <input id="dSlope" type="range" min="0" max="5" step="0.1" value="2">

      <label>Supply steepness (0 = flat / perfectly elastic)</label>
      <input id="sSlope" type="range" min="0" max="5" step="0.1" value="1.5">

      <hr style="border:none;border-top:1px solid #eee;margin:12px 0">

      <label>Price control line (optional)</label>
      <input id="priceControl" type="range" min="0" max="100" step="1" value="50">
      <div class="pcRow">
        <label class="pill"><input id="pcNone" type="radio" name="pc" checked> None</label>
        <label class="pill"><input id="pcCeil" type="radio" name="pc"> Ceiling</label>
        <label class="pill"><input id="pcFloor" type="radio" name="pc"> Floor</label>
        <span class="pill">P = <span id="pcVal">50</span></span>
      </div>

      <div class="info">
        <div class="stat"><strong>Equilibrium Price:</strong> <span id="peq">—</span></div>
        <div class="stat"><strong>Equilibrium Quantity:</strong> <span id="qeq">—</span></div>
        <div class="small" id="pcNote">—</div>
      </div>
    </div>

    <canvas id="chart" width="720" height="480"></canvas>
  </div>

  <script>
    // Fixed-axis (0–100) supply & demand demo
    const canvas = document.getElementById('chart');
    const ctx = canvas.getContext('2d');

    const dInterceptEl = document.getElementById('dIntercept');
    const sInterceptEl = document.getElementById('sIntercept');
    const dSlopeEl = document.getElementById('dSlope');
    const sSlopeEl = document.getElementById('sSlope');

    const priceControlEl = document.getElementById('priceControl');
    const pcNone = document.getElementById('pcNone');
    const pcCeil = document.getElementById('pcCeil');
    const pcFloor = document.getElementById('pcFloor');
    const pcValEl = document.getElementById('pcVal');

    const peqEl = document.getElementById('peq');
    const qeqEl = document.getElementById('qeq');
    const pcNoteEl = document.getElementById('pcNote');
    const resetBtn = document.getElementById('resetBtn');

    // Fixed axis ranges
    const Q_MIN = 0, Q_MAX = 100;
    const P_MIN = 0, P_MAX = 100;

    function clamp(x, a, b){ return Math.min(b, Math.max(a, x)); }

    // --- draw logic ---
    function draw(){
      const d0 = parseFloat(dInterceptEl.value);
      const s0 = parseFloat(sInterceptEl.value);

      // "Steepness" sliders
      const kd = parseFloat(dSlopeEl.value);
      const ks = parseFloat(sSlopeEl.value);

      // Param as linear P = A - m*Q (demand), P = B + n*Q (supply)
      const A_d = 80 + d0*4; // demand vertical position
      const A_s = 20 + s0*4; // supply vertical position
      const m_d = kd * 0.8;
      const m_s = ks * 0.8;

      function P_d(Q){ return A_d - m_d * Q; }
      function P_s(Q){ return A_s + m_s * Q; }

      // Solve equilibrium: (m_d + m_s) Q = (A_d - A_s)
      let Q_eq, P_eq;
      const denom = (m_d + m_s);

      if (Math.abs(denom) < 1e-9) {
        // Nearly parallel horizontals - fallback midpoint so students can see behavior
        Q_eq = 50;
        P_eq = (P_d(50) + P_s(50)) / 2;
      } else {
        Q_eq = (A_d - A_s) / denom;
        P_eq = P_s(Q_eq);
      }

      Q_eq = clamp(Q_eq, Q_MIN, Q_MAX);
      P_eq = clamp(P_eq, P_MIN, P_MAX);

      peqEl.textContent = P_eq.toFixed(2);
      qeqEl.textContent = Q_eq.toFixed(2);

      // mapping
      const pad = 60;
      const w = canvas.width - pad*2;
      const h = canvas.height - pad*2;

      function xFromQ(q){ return pad + ((q - Q_MIN)/(Q_MAX - Q_MIN))*w; }
      function yFromP(p){ return pad + h - ((p - P_MIN)/(P_MAX - P_MIN))*h; }

      // clear
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // axes
      ctx.strokeStyle = '#222'; ctx.lineWidth=1;
      ctx.beginPath();
      ctx.moveTo(pad, pad+h); ctx.lineTo(pad+w, pad+h); // x-axis
      ctx.moveTo(pad, pad);   ctx.lineTo(pad, pad+h);   // y-axis
      ctx.stroke();

      // grid + ticks
      ctx.font = '11px system-ui';
      ctx.fillStyle = '#555';
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      for(let t=0;t<=5;t++){
        const q = t*20;
        const x = xFromQ(q);
        ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, pad+h); ctx.stroke();
        ctx.fillText(q.toString(), x-6, pad+h+18);
      }
      for(let t=0;t<=5;t++){
        const p = t*20;
        const y = yFromP(p);
        ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(pad+w, y); ctx.stroke();
        ctx.fillText(p.toString(), pad-28, y+4);
      }

      // labels
      ctx.fillStyle='#333'; ctx.font='12px system-ui';
      ctx.fillText('Quantity', pad + w - 46, pad + h + 34);
      ctx.save(); ctx.translate(pad-44, pad+24); ctx.rotate(-Math.PI/2); ctx.fillText('Price', 0,0); ctx.restore();

      // Plot curves by Q from 0..100 but stop drawing segments whenever P is outside [0,100]
      function plotCurveWithClipping(PofQ, color){
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        let drawing = false;
        ctx.beginPath();
        const steps = 240;
        for(let i=0;i<=steps;i++){
          const Q = Q_MIN + (i/steps)*(Q_MAX - Q_MIN);
          const P = PofQ(Q);
          const inside = (P >= P_MIN - 1e-6 && P <= P_MAX + 1e-6);
          const x = xFromQ(Q);
          const y = yFromP(clamp(P, P_MIN, P_MAX));
          if(inside){
            if(!drawing){
              ctx.moveTo(x,y);
              drawing = true;
            } else {
              ctx.lineTo(x,y);
            }
          } else {
            // end current segment (if any) and skip drawing until back inside
            drawing = false;
          }
        }
        ctx.stroke();
      }

      plotCurveWithClipping(P_d, '#d64545'); // demand
      plotCurveWithClipping(P_s, '#2a9d8f'); // supply

      // Equilibrium crosshair (dotted)
      const xe = xFromQ(Q_eq);
      const ye = yFromP(P_eq);

      ctx.strokeStyle='rgba(0,0,0,0.18)'; ctx.lineWidth=1;
      ctx.setLineDash([6,6]);
      ctx.beginPath(); ctx.moveTo(pad, ye); ctx.lineTo(xe, ye); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(xe, pad+h); ctx.lineTo(xe, ye); ctx.stroke();
      ctx.setLineDash([]);

      // Equilibrium point
      ctx.fillStyle = '#111';
      ctx.beginPath(); ctx.arc(xe, ye, 5, 0, Math.PI*2); ctx.fill();
      ctx.font='13px system-ui'; ctx.fillText('E', xe+8, ye-8);

      // Legend
      ctx.fillStyle='#d64545'; ctx.fillRect(canvas.width-150, pad-8, 12, 8);
      ctx.fillStyle='#333'; ctx.fillText('Demand', canvas.width-132, pad);
      ctx.fillStyle='#2a9d8f'; ctx.fillRect(canvas.width-150, pad+12, 12, 8);
      ctx.fillStyle='#333'; ctx.fillText('Supply', canvas.width-132, pad+20);

      // Price control line + shortage/surplus markers
      const pc = parseFloat(priceControlEl.value);
      pcValEl.textContent = pc.toFixed(0);
      const mode = pcCeil.checked ? 'ceiling' : (pcFloor.checked ? 'floor' : 'none');

      if(mode === 'none'){
        pcNoteEl.textContent = 'No price control line.';
        return;
      }

      // draw horizontal price line
      const ypc = yFromP(pc);
      ctx.lineWidth = 2;
      ctx.setLineDash([6,6]);
      ctx.strokeStyle = (mode === 'ceiling') ? '#f4b400' : '#34a853';
      ctx.beginPath(); ctx.moveTo(pad, ypc); ctx.lineTo(pad+w, ypc); ctx.stroke();
      ctx.setLineDash([]);

      // Qd and Qs at the controlled price
      function QdAtPrice(p){
        if(Math.abs(m_d) < 1e-9){
          if (Math.abs(p - A_d) < 1e-6) return 50;
          return (p > A_d) ? 0 : 100;
        }
        return (A_d - p) / m_d;
      }
      function QsAtPrice(p){
        if(Math.abs(m_s) < 1e-9){
          if (Math.abs(p - A_s) < 1e-6) return 50;
          return (p < A_s) ? 0 : 100;
        }
        return (p - A_s) / m_s;
      }

      let Qd = clamp(QdAtPrice(pc), Q_MIN, Q_MAX);
      let Qs = clamp(QsAtPrice(pc), Q_MIN, Q_MAX);

      // mark points if they are within the view
      function markPoint(Q, p, color, label){
        if(p < P_MIN - 1e-6 || p > P_MAX + 1e-6) return;
        const x = xFromQ(Q);
        const y = yFromP(p);
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#333';
        ctx.font = '12px system-ui';
        ctx.fillText(label, x+8, y-8);
      }

      markPoint(Qd, pc, '#d64545', 'QD');
      markPoint(Qs, pc, '#2a9d8f', 'QS');

      if(mode === 'ceiling'){
        const binding = pc < P_eq;
        if(binding){
          const shortage = Math.max(0, Qd - Qs);
          pcNoteEl.textContent = `Binding ceiling: shortage ≈ ${shortage.toFixed(2)} (QD - QS at P=${pc.toFixed(0)}).`;
          // bracket
          ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.lineWidth=2;
          ctx.beginPath(); ctx.moveTo(xFromQ(Qs), ypc+12); ctx.lineTo(xFromQ(Qd), ypc+12); ctx.stroke();
        } else {
          pcNoteEl.textContent = `Non-binding ceiling: market stays at equilibrium.`;
        }
      } else {
        const binding = pc > P_eq;
        if(binding){
          const surplus = Math.max(0, Qs - Qd);
          pcNoteEl.textContent = `Binding floor: surplus ≈ ${surplus.toFixed(2)} (QS - QD at P=${pc.toFixed(0)}).`;
          ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.lineWidth=2;
          ctx.beginPath(); ctx.moveTo(xFromQ(Qd), ypc+12); ctx.lineTo(xFromQ(Qs), ypc+12); ctx.stroke();
        } else {
          pcNoteEl.textContent = `Non-binding floor: market stays at equilibrium.`;
        }
      }
    }

    // --- events & reset ---
    function wireEvents(){
      const inputs = [dInterceptEl, sInterceptEl, dSlopeEl, sSlopeEl, priceControlEl, pcNone, pcCeil, pcFloor];
      inputs.forEach(el => {
        el.addEventListener('input', draw);
        el.addEventListener('change', draw);
      });

      resetBtn.addEventListener('click', ()=> {
        // defaults match initial values above
        dInterceptEl.value = 0;
        sInterceptEl.value = 0;
        dSlopeEl.value = 2;
        sSlopeEl.value = 1.5;
        priceControlEl.value = 50;
        pcNone.checked = true;
        // ensure UI updates
        draw();
      });
    }

    // init
    wireEvents();
    draw();

    // handle high-DPI canvas sizing (optional improvement)
    (function adjustDPI(){
      const dpr = window.devicePixelRatio || 1;
      const styleW = canvas.clientWidth;
      const styleH = canvas.clientHeight;
      canvas.width = Math.round(styleW * dpr);
      canvas.height = Math.round(styleH * dpr);
      ctx.scale(dpr, dpr);
      draw();
    })();
  </script>
</body>
</html>
