<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Supply & Demand Demo (Fixed Axes)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:18px;color:#111}
    h1{font-size:20px;margin-bottom:6px}
    .row{display:flex;gap:18px;align-items:flex-start}
    .controls{width:320px}
    label{display:block;margin:10px 0 6px;font-weight:600}
    input[type=range]{width:100%}
    canvas{background:#fbfbfb;border:1px solid #e6e6e6;border-radius:8px}
    .info{margin-top:12px}
    .stat{margin:6px 0}
    .muted{color:#666;font-size:13px}
    .small{color:#666;font-size:12px}
    .pcRow{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:8px}
    .pill{display:inline-block;padding:4px 8px;border-radius:999px;border:1px solid #e6e6e6;background:#fff;font-size:12px}
  </style>
</head>
<body>
  <h1>Interactive Supply & Demand Demo</h1>
  <p class="muted">Axes are fixed (0–100). Shift curves and watch equilibrium move without the graph rescaling.</p>

  <div class="row">
    <div class="controls">
      <label>Demand shift (right = higher demand)</label>
      <input id="dIntercept" type="range" min="-8" max="8" step="0.5" value="0">
      <div class="small">This moves demand right/left, axes stay fixed.</div>

      <label>Supply shift (right = higher supply)</label>
      <input id="sIntercept" type="range" min="-8" max="8" step="0.5" value="0">

      <label>Demand steepness (steeper = more inelastic)</label>
      <input id="dSlope" type="range" min="0" max="5" step="0.1" value="2">
      <div class="small">0 = perfectly elastic (horizontal). Higher = steeper demand curve.</div>

      <label>Supply steepness (steeper = more inelastic)</label>
      <input id="sSlope" type="range" min="0" max="5" step="0.1" value="1.5">
      <div class="small">0 = perfectly elastic (horizontal). Higher = steeper supply curve.</div>

      <hr style="border:none;border-top:1px solid #eee;margin:12px 0">

      <label>Price control line (optional)</label>
      <input id="priceControl" type="range" min="0" max="100" step="1" value="50">
      <div class="pcRow">
        <label class="pill"><input id="pcNone" type="radio" name="pc" checked> None</label>
        <label class="pill"><input id="pcCeil" type="radio" name="pc"> Ceiling</label>
        <label class="pill"><input id="pcFloor" type="radio" name="pc"> Floor</label>
        <span class="pill">P = <span id="pcVal">50</span></span>
      </div>

      <div class="info">
        <div class="stat"><strong>Equilibrium Price:</strong> <span id="peq">—</span></div>
        <div class="stat"><strong>Equilibrium Quantity:</strong> <span id="qeq">—</span></div>
        <div class="small" id="pcNote">—</div>
      </div>
    </div>

    <canvas id="chart" width="720" height="480"></canvas>
  </div>

  <script>
    // Fixed-axis (0–100) supply & demand demo
    const canvas = document.getElementById('chart');
    const ctx = canvas.getContext('2d');

    const dInterceptEl = document.getElementById('dIntercept');
    const sInterceptEl = document.getElementById('sIntercept');
    const dSlopeEl = document.getElementById('dSlope');
    const sSlopeEl = document.getElementById('sSlope');

    const priceControlEl = document.getElementById('priceControl');
    const pcNone = document.getElementById('pcNone');
    const pcCeil = document.getElementById('pcCeil');
    const pcFloor = document.getElementById('pcFloor');
    const pcValEl = document.getElementById('pcVal');

    const peqEl = document.getElementById('peq');
    const qeqEl = document.getElementById('qeq');
    const pcNoteEl = document.getElementById('pcNote');

    // Fixed axis ranges
    const Q_MIN = 0, Q_MAX = 100;
    const P_MIN = 0, P_MAX = 100;

    function clamp(x, a, b){ return Math.min(b, Math.max(a, x)); }

    function draw(){
      const d0 = parseFloat(dInterceptEl.value);
      const s0 = parseFloat(sInterceptEl.value);

      // "Steepness" sliders
      // Use 0 to mean perfectly elastic (horizontal line).
      const kd = parseFloat(dSlopeEl.value);
      const ks = parseFloat(sSlopeEl.value);

      // Build linear-ish curves in "P as function of Q" form for easy plotting:
      // Demand: P = A_d - m_d * Q
      // Supply: P = A_s + m_s * Q
      //
      // When kd = 0: m_d = 0 -> horizontal demand at A_d (perfectly elastic)
      // When ks = 0: m_s = 0 -> horizontal supply at A_s (perfectly elastic)

      const A_d = 80 + d0*4;           // demand vertical position (up/down)
      const A_s = 20 + s0*4;           // supply vertical position (up/down)
      const m_d = kd * 0.8;            // demand slope magnitude
      const m_s = ks * 0.8;            // supply slope magnitude

      function P_d(Q){ return A_d - m_d * Q; }
      function P_s(Q){ return A_s + m_s * Q; }

      // Solve equilibrium:
      // A_d - m_d Q = A_s + m_s Q
      // (m_d + m_s) Q = (A_d - A_s)
      let Q_eq, P_eq;

      const denom = (m_d + m_s);

      if (Math.abs(denom) < 1e-9){
        // Both are (nearly) horizontal and parallel: no unique intersection.
        // We'll pick the midpoint as a pedagogical fallback.
        Q_eq = 50;
        P_eq = (P_d(50) + P_s(50)) / 2;
      } else {
        Q_eq = (A_d - A_s) / denom;
        P_eq = P_s(Q_eq);
      }

      // Clamp equilibrium to the viewing box
      Q_eq = clamp(Q_eq, Q_MIN, Q_MAX);
      P_eq = clamp(P_eq, P_MIN, P_MAX);

      peqEl.textContent = P_eq.toFixed(2);
      qeqEl.textContent = Q_eq.toFixed(2);

      // Mapping: fixed axes 0–100
      const pad = 60;
      const w = canvas.width - pad*2;
      const h = canvas.height - pad*2;

      function xFromQ(q){ return pad + ((q - Q_MIN)/(Q_MAX - Q_MIN))*w; }
      function yFromP(p){ return pad + h - ((p - P_MIN)/(P_MAX - P_MIN))*h; }

      // Clear
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // Axes
      ctx.strokeStyle = '#222'; ctx.lineWidth=1;
      ctx.beginPath();
      ctx.moveTo(pad, pad+h); ctx.lineTo(pad+w, pad+h); // x-axis
      ctx.moveTo(pad, pad);   ctx.lineTo(pad, pad+h);   // y-axis
      ctx.stroke();

      // Grid + ticks (0..100)
      ctx.font = '11px system-ui';
      ctx.fillStyle = '#555';
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      for(let t=0;t<=5;t++){
        const q = t*20;
        const x = xFromQ(q);
        ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, pad+h); ctx.stroke();
        ctx.fillText(q.toString(), x-6, pad+h+18);
      }
      for(let t=0;t<=5;t++){
        const p = t*20;
        const y = yFromP(p);
        ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(pad+w, y); ctx.stroke();
        ctx.fillText(p.toString(), pad-28, y+4);
      }

      // Labels
      ctx.fillStyle='#333'; ctx.font='12px system-ui';
      ctx.fillText('Quantity', pad + w - 46, pad + h + 34);
      ctx.save(); ctx.translate(pad-44, pad+24); ctx.rotate(-Math.PI/2); ctx.fillText('Price', 0,0); ctx.restore();

      // Plot curves by Q from 0..100 (fixed)
      function plotCurve(PofQ, color){
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        for(let i=0;i<=200;i++){
          const Q = Q_MIN + (i/200)*(Q_MAX - Q_MIN);
          let P = PofQ(Q);
          // clamp to box so it stays in frame
          P = clamp(P, P_MIN, P_MAX);
          const x = xFromQ(Q);
          const y = yFromP(P);
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();
      }

      plotCurve(P_d, '#d64545'); // demand
      plotCurve(P_s, '#2a9d8f'); // supply

      // Equilibrium crosshair (dotted)
      const xe = xFromQ(Q_eq);
      const ye = yFromP(P_eq);

      ctx.strokeStyle='rgba(0,0,0,0.18)'; ctx.lineWidth=1;
      ctx.setLineDash([6,6]);
      ctx.beginPath(); ctx.moveTo(pad, ye); ctx.lineTo(xe, ye); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(xe, pad+h); ctx.lineTo(xe, ye); ctx.stroke();
      ctx.setLineDash([]);

      // Equilibrium point
      ctx.fillStyle = '#111';
      ctx.beginPath(); ctx.arc(xe, ye, 5, 0, Math.PI*2); ctx.fill();
      ctx.font='13px system-ui'; ctx.fillText('E', xe+8, ye-8);

      // Legend
      ctx.fillStyle='#d64545'; ctx.fillRect(canvas.width-150, pad-8, 12, 8);
      ctx.fillStyle='#333'; ctx.fillText('Demand', canvas.width-132, pad);
      ctx.fillStyle='#2a9d8f'; ctx.fillRect(canvas.width-150, pad+12, 12, 8);
      ctx.fillStyle='#333'; ctx.fillText('Supply', canvas.width-132, pad+20);

      // Price control line + shortage/surplus markers
      const pc = parseFloat(priceControlEl.value);
      pcValEl.textContent = pc.toFixed(0);

      const mode = pcCeil.checked ? 'ceiling' : (pcFloor.checked ? 'floor' : 'none');

      if(mode === 'none'){
        pcNoteEl.textContent = 'No price control line.';
        return;
      }

      // Draw horizontal price line
      const ypc = yFromP(pc);
      ctx.lineWidth = 2;
      ctx.setLineDash([6,6]);
      ctx.strokeStyle = (mode === 'ceiling') ? '#f4b400' : '#34a853';
      ctx.beginPath(); ctx.moveTo(pad, ypc); ctx.lineTo(pad+w, ypc); ctx.stroke();
      ctx.setLineDash([]);

      // Find Qd and Qs at the controlled price:
      // For demand: pc = A_d - m_d Q => Qd = (A_d - pc)/m_d, but if m_d==0 horizontal demand:
      //   if pc == A_d -> any Q; we'll show mid as 50
      //   if pc > A_d -> Qd=0; if pc < A_d -> Qd=100
      function QdAtPrice(p){
        if(Math.abs(m_d) < 1e-9){
          if (Math.abs(p - A_d) < 1e-6) return 50;
          return (p > A_d) ? 0 : 100;
        }
        return (A_d - p) / m_d;
      }
      function QsAtPrice(p){
        if(Math.abs(m_s) < 1e-9){
          if (Math.abs(p - A_s) < 1e-6) return 50;
          return (p < A_s) ? 0 : 100;
        }
        return (p - A_s) / m_s;
      }

      let Qd = clamp(QdAtPrice(pc), Q_MIN, Q_MAX);
      let Qs = clamp(QsAtPrice(pc), Q_MIN, Q_MAX);

      // Mark intersection points on the price line (visual shortage/surplus)
      function markPoint(Q, p, color, label){
        const x = xFromQ(Q);
        const y = yFromP(p);
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#333';
        ctx.font = '12px system-ui';
        ctx.fillText(label, x+8, y-8);
      }

      markPoint(Qd, pc, '#d64545', 'QD');
      markPoint(Qs, pc, '#2a9d8f', 'QS');

      if(mode === 'ceiling'){
        const binding = pc < P_eq;
        if(binding){
          const shortage = Math.max(0, Qd - Qs);
          pcNoteEl.textContent = `Binding ceiling: shortage ≈ ${shortage.toFixed(2)} (QD - QS at P=${pc.toFixed(0)}).`;
          // draw bracket line between QS and QD
          ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.lineWidth=2;
          ctx.beginPath(); ctx.moveTo(xFromQ(Qs), ypc+12); ctx.lineTo(xFromQ(Qd), ypc+12); ctx.stroke();
        }else{
          pcNoteEl.textContent = `Non-binding ceiling: market stays at equilibrium.`;
        }
      } else {
        const binding = pc > P_eq;
        if(binding){
          const surplus = Math.max(0, Qs - Qd);
          pcNoteEl.textContent = `Binding floor: surplus ≈ ${surplus.toFixed(2)} (QS - QD at P=${pc.toFixed(0)}).`;
          ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.lineWidth=2;
          ctx.beginPath(); ctx.moveTo(xFromQ(Qd), ypc+12); ctx.lineTo(xFromQ(Qs), ypc+12); ctx.stroke();
        }else{
          pcNoteEl.textContent = `Non-binding floor: market stays at equilibrium.`;
        }
      }
    }

    // Events
    [dInterceptEl, sInterceptEl, dSlopeEl, sSlopeEl, priceControlEl, pcNone, pcCeil, pcFloor].forEach(el=>{
      el.addEventListener('input', draw);
      el.addEventListener('change', draw);
    });

    draw();
  </script>
</body>
</html>
