<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Supply & Demand Demo (Fixed Axes)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:18px;color:#111}
    h1{font-size:20px;margin-bottom:6px}
    .row{display:flex;gap:18px;align-items:flex-start}
    .controls{width:340px}
    @media (max-width: 900px){.row{flex-direction:column}.controls{width:100%}}
    label{display:block;margin:10px 0 6px;font-weight:600}
    input[type=range]{width:100%}
    canvas{background:#fbfbfb;border:1px solid #e6e6e6;border-radius:8px;display:block}
    .muted{color:#666;font-size:13px;margin:0 0 10px}
    .small{color:#666;font-size:12px}
    .pcRow{display:flex;gap:10px;align-items:center;flex-wrap:wrap;margin-top:8px}
    .pill{display:inline-block;padding:4px 8px;border-radius:999px;border:1px solid #e6e6e6;background:#fff;font-size:12px}
    .card{border:1px solid #e6e6e6;border-radius:10px;padding:12px;background:#fff}
    .topbar{display:flex;align-items:center;justify-content:space-between;gap:12px}
    .resetBtn{
      width:36px;height:36px;border-radius:999px;border:1px solid #e6e6e6;
      background:#fff;cursor:pointer;font-size:16px;line-height:1;display:inline-flex;
      align-items:center;justify-content:center;transition:transform .12s ease, box-shadow .12s ease;
    }
    .resetBtn:hover{box-shadow:0 4px 14px rgba(0,0,0,.08);transform:translateY(-1px)}
    .resetBtn:active{transform:translateY(0px) scale(.98)}
    .stats{margin-top:10px;padding-top:10px;border-top:1px solid #eee}
    .stat{margin:6px 0}
  </style>
</head>
<body>
  <h1>Interactive Supply & Demand Demo</h1>
  <p class="muted">Axes are fixed (0–100). Curves stop drawing when they leave the visible price range. Reset snaps everything back.</p>

  <div class="row">
    <div class="controls card">
      <div class="topbar">
        <div style="font-weight:700">Controls</div>
        <button id="resetBtn" class="resetBtn" title="Reset sliders to center">↺</button>
      </div>
      <div class="small" style="margin-top:6px;">Tip: set steepness to <b>0</b> for a flat (perfectly elastic) curve.</div>

      <label>Demand shift (higher = demand up)</label>
      <input id="dIntercept" type="range" min="-8" max="8" step="0.5" value="0">

      <label>Supply shift (higher = supply up)</label>
      <input id="sIntercept" type="range" min="-8" max="8" step="0.5" value="0">

      <label>Demand steepness (0 = flat / perfectly elastic)</label>
      <input id="dSlope" type="range" min="0" max="5" step="0.1" value="2">

      <label>Supply steepness (0 = flat / perfectly elastic)</label>
      <input id="sSlope" type="range" min="0" max="5" step="0.1" value="1.5">

      <hr style="border:none;border-top:1px solid #eee;margin:12px 0">

      <label>Price control line (optional)</label>
      <input id="priceControl" type="range" min="0" max="100" step="1" value="50">
      <div class="pcRow">
        <label class="pill"><input id="pcNone" type="radio" name="pc" checked> None</label>
        <label class="pill"><input id="pcCeil" type="radio" name="pc"> Ceiling</label>
        <label class="pill"><input id="pcFloor" type="radio" name="pc"> Floor</label>
        <span class="pill">P = <span id="pcVal">50</span></span>
      </div>

      <div class="stats">
        <div class="stat"><strong>Equilibrium Price:</strong> <span id="peq">—</span></div>
        <div class="stat"><strong>Equilibrium Quantity:</strong> <span id="qeq">—</span></div>
        <div class="small" id="pcNote">—</div>
      </div>
    </div>

    <div class="card" style="flex:1">
      <canvas id="chart" width="720" height="480"></canvas>
      <div class="small" style="margin-top:8px;">Demand = red, Supply = green. Equilibrium guides are dotted.</div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('chart');
    const ctx = canvas.getContext('2d');

    const dInterceptEl = document.getElementById('dIntercept');
    const sInterceptEl = document.getElementById('sIntercept');
    const dSlopeEl = document.getElementById('dSlope');
    const sSlopeEl = document.getElementById('sSlope');

    const priceControlEl = document.getElementById('priceControl');
    const pcNone = document.getElementById('pcNone');
    const pcCeil = document.getElementById('pcCeil');
    const pcFloor = document.getElementById('pcFloor');
    const pcValEl = document.getElementById('pcVal');

    const peqEl = document.getElementById('peq');
    const qeqEl = document.getElementById('qeq');
    const pcNoteEl = document.getElementById('pcNote');
    const resetBtn = document.getElementById('resetBtn');

    // Fixed axis ranges
    const Q_MIN = 0, Q_MAX = 100;
    const P_MIN = 0, P_MAX = 100;

    const DEFAULTS = {
      dIntercept: 0,
      sIntercept: 0,
      dSlope: 2,
      sSlope: 1.5,
      priceControl: 50,
      pcMode: 'none'
    };

    function clamp(x, a, b){ return Math.min(b, Math.max(a, x)); }

    let resetAnimating = false;
    let pulseT = 0; // for a tiny equilibrium pulse during reset

    function getState(){
      return {
        dIntercept: parseFloat(dInterceptEl.value),
        sIntercept: parseFloat(sInterceptEl.value),
        dSlope: parseFloat(dSlopeEl.value),
        sSlope: parseFloat(sSlopeEl.value),
        priceControl: parseFloat(priceControlEl.value),
        pcMode: pcCeil.checked ? 'ceiling' : (pcFloor.checked ? 'floor' : 'none')
      };
    }

    function setState(s){
      dInterceptEl.value = s.dIntercept;
      sInterceptEl.value = s.sIntercept;
      dSlopeEl.value = s.dSlope;
      sSlopeEl.value = s.sSlope;
      priceControlEl.value = s.priceControl;

      if(s.pcMode === 'ceiling'){ pcCeil.checked = true; }
      else if(s.pcMode === 'floor'){ pcFloor.checked = true; }
      else { pcNone.checked = true; }
    }

    function draw(){
      const d0 = parseFloat(dInterceptEl.value);
      const s0 = parseFloat(sInterceptEl.value);
      const kd = parseFloat(dSlopeEl.value);
      const ks = parseFloat(sSlopeEl.value);

      // Curves in P(Q) form
      const A_d = 80 + d0*4;
      const A_s = 20 + s0*4;
      const m_d = kd * 0.8;
      const m_s = ks * 0.8;

      function P_d(Q){ return A_d - m_d * Q; }
      function P_s(Q){ return A_s + m_s * Q; }

      // Equilibrium solve
      let Q_eq, P_eq;
      const denom = (m_d + m_s);

      if (Math.abs(denom) < 1e-9) {
        Q_eq = 50;
        P_eq = (P_d(50) + P_s(50)) / 2;
      } else {
        Q_eq = (A_d - A_s) / denom;
        P_eq = P_s(Q_eq);
      }

      Q_eq = clamp(Q_eq, Q_MIN, Q_MAX);
      P_eq = clamp(P_eq, P_MIN, P_MAX);

      peqEl.textContent = P_eq.toFixed(2);
      qeqEl.textContent = Q_eq.toFixed(2);

      // mapping
      const pad = 60;
      const w = canvas.width - pad*2;
      const h = canvas.height - pad*2;

      function xFromQ(q){ return pad + ((q - Q_MIN)/(Q_MAX - Q_MIN))*w; }
      function yFromP(p){ return pad + h - ((p - P_MIN)/(P_MAX - P_MIN))*h; }

      ctx.clearRect(0,0,canvas.width,canvas.height);

      // axes
      ctx.strokeStyle = '#222'; ctx.lineWidth=1;
      ctx.beginPath();
      ctx.moveTo(pad, pad+h); ctx.lineTo(pad+w, pad+h);
      ctx.moveTo(pad, pad);   ctx.lineTo(pad, pad+h);
      ctx.stroke();

      // grid + ticks
      ctx.font = '11px system-ui';
      ctx.fillStyle = '#555';
      ctx.strokeStyle = 'rgba(0,0,0,0.06)';
      for(let t=0;t<=5;t++){
        const q = t*20;
        const x = xFromQ(q);
        ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, pad+h); ctx.stroke();
        ctx.fillText(q.toString(), x-6, pad+h+18);
      }
      for(let t=0;t<=5;t++){
        const p = t*20;
        const y = yFromP(p);
        ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(pad+w, y); ctx.stroke();
        ctx.fillText(p.toString(), pad-28, y+4);
      }

      // labels
      ctx.fillStyle='#333'; ctx.font='12px system-ui';
      ctx.fillText('Quantity', pad + w - 46, pad + h + 34);
      ctx.save(); ctx.translate(pad-44, pad+24); ctx.rotate(-Math.PI/2); ctx.fillText('Price', 0,0); ctx.restore();

      // plot curves: DO NOT clamp to edges, just stop drawing when outside range
      function plotCurveClipped(PofQ, color){
        ctx.strokeStyle = color;
        ctx.lineWidth = 3;
        ctx.beginPath();
        let drawing = false;

        const steps = 260;
        for(let i=0;i<=steps;i++){
          const Q = Q_MIN + (i/steps)*(Q_MAX - Q_MIN);
          const P = PofQ(Q);
          const inside = (P >= P_MIN && P <= P_MAX);
          if(inside){
            const x = xFromQ(Q);
            const y = yFromP(P);
            if(!drawing){ ctx.moveTo(x,y); drawing = true; }
            else { ctx.lineTo(x,y); }
          } else {
            drawing = false;
          }
        }
        ctx.stroke();
      }

      plotCurveClipped(P_d, '#d64545'); // demand
      plotCurveClipped(P_s, '#2a9d8f'); // supply

      // equilibrium guides
      const xe = xFromQ(Q_eq);
      const ye = yFromP(P_eq);

      ctx.strokeStyle='rgba(0,0,0,0.18)'; ctx.lineWidth=1;
      ctx.setLineDash([6,6]);
      ctx.beginPath(); ctx.moveTo(pad, ye); ctx.lineTo(xe, ye); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(xe, pad+h); ctx.lineTo(xe, ye); ctx.stroke();
      ctx.setLineDash([]);

      // equilibrium point (pulse during reset)
      const baseR = 5;
      const pulse = resetAnimating ? (2.5 * Math.abs(Math.sin(pulseT))) : 0;
      ctx.fillStyle = '#111';
      ctx.beginPath(); ctx.arc(xe, ye, baseR + pulse, 0, Math.PI*2); ctx.fill();
      ctx.font='13px system-ui'; ctx.fillText('E', xe+8, ye-8);

      // price control
      const pc = parseFloat(priceControlEl.value);
      pcValEl.textContent = pc.toFixed(0);
      const mode = pcCeil.checked ? 'ceiling' : (pcFloor.checked ? 'floor' : 'none');

      if(mode === 'none'){
        pcNoteEl.textContent = 'No price control line.';
        return;
      }

      const ypc = yFromP(pc);
      ctx.lineWidth = 2;
      ctx.setLineDash([6,6]);
      ctx.strokeStyle = (mode === 'ceiling') ? '#f4b400' : '#34a853';
      ctx.beginPath(); ctx.moveTo(pad, ypc); ctx.lineTo(pad+w, ypc); ctx.stroke();
      ctx.setLineDash([]);

      function QdAtPrice(p){
        if(Math.abs(m_d) < 1e-9){
          if (Math.abs(p - A_d) < 1e-6) return 50;
          return (p > A_d) ? 0 : 100;
        }
        return (A_d - p) / m_d;
      }
      function QsAtPrice(p){
        if(Math.abs(m_s) < 1e-9){
          if (Math.abs(p - A_s) < 1e-6) return 50;
          return (p < A_s) ? 0 : 100;
        }
        return (p - A_s) / m_s;
      }

      let Qd = clamp(QdAtPrice(pc), Q_MIN, Q_MAX);
      let Qs = clamp(QsAtPrice(pc), Q_MIN, Q_MAX);

      function markPoint(Q, p, color, label){
        if(p < P_MIN || p > P_MAX) return;
        const x = xFromQ(Q);
        const y = yFromP(p);
        ctx.fillStyle = color;
        ctx.beginPath(); ctx.arc(x, y, 5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#333';
        ctx.font = '12px system-ui';
        ctx.fillText(label, x+8, y-8);
      }

      markPoint(Qd, pc, '#d64545', 'QD');
      markPoint(Qs, pc, '#2a9d8f', 'QS');

      if(mode === 'ceiling'){
        const binding = pc < P_eq;
        if(binding){
          const shortage = Math.max(0, Qd - Qs);
          pcNoteEl.textContent = `Binding ceiling: shortage ≈ ${shortage.toFixed(2)} (QD - QS at P=${pc.toFixed(0)}).`;
          ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.lineWidth=2;
          ctx.beginPath(); ctx.moveTo(xFromQ(Qs), ypc+12); ctx.lineTo(xFromQ(Qd), ypc+12); ctx.stroke();
        } else {
          pcNoteEl.textContent = 'Non-binding ceiling: market stays at equilibrium.';
        }
      } else {
        const binding = pc > P_eq;
        if(binding){
          const surplus = Math.max(0, Qs - Qd);
          pcNoteEl.textContent = `Binding floor: surplus ≈ ${surplus.toFixed(2)} (QS - QD at P=${pc.toFixed(0)}).`;
          ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.lineWidth=2;
          ctx.beginPath(); ctx.moveTo(xFromQ(Qd), ypc+12); ctx.lineTo(xFromQ(Qs), ypc+12); ctx.stroke();
        } else {
          pcNoteEl.textContent = 'Non-binding floor: market stays at equilibrium.';
        }
      }
    }

    function setInputsDisabled(disabled){
      [dInterceptEl,sInterceptEl,dSlopeEl,sSlopeEl,priceControlEl,pcNone,pcCeil,pcFloor].forEach(el => el.disabled = disabled);
    }

    function animateReset(){
      if(resetAnimating) return;
      resetAnimating = true;
      setInputsDisabled(true);

      const start = getState();
      const end = {
        dIntercept: DEFAULTS.dIntercept,
        sIntercept: DEFAULTS.sIntercept,
        dSlope: DEFAULTS.dSlope,
        sSlope: DEFAULTS.sSlope,
        priceControl: DEFAULTS.priceControl,
        pcMode: DEFAULTS.pcMode
      };

      const duration = 350;
      const t0 = performance.now();

      function easeOutCubic(x){ return 1 - Math.pow(1 - x, 3); }

      function frame(now){
        const raw = (now - t0) / duration;
        const u = clamp(raw, 0, 1);
        const e = easeOutCubic(u);

        pulseT += 0.35;

        const cur = {
          dIntercept: start.dIntercept + (end.dIntercept - start.dIntercept)*e,
          sIntercept: start.sIntercept + (end.sIntercept - start.sIntercept)*e,
          dSlope: start.dSlope + (end.dSlope - start.dSlope)*e,
          sSlope: start.sSlope + (end.sSlope - start.sSlope)*e,
          priceControl: start.priceControl + (end.priceControl - start.priceControl)*e,
          pcMode: (u < 1) ? start.pcMode : end.pcMode
        };

        setState(cur);
        draw();

        if(u < 1){
          requestAnimationFrame(frame);
        } else {
          // finalize mode + cleanup
          setState(end);
          pulseT = 0;
          resetAnimating = false;
          setInputsDisabled(false);
          draw();
        }
      }

      requestAnimationFrame(frame);
    }

    // events
    [dInterceptEl, sInterceptEl, dSlopeEl, sSlopeEl, priceControlEl, pcNone, pcCeil, pcFloor].forEach(el=>{
      el.addEventListener('input', draw);
      el.addEventListener('change', draw);
    });

    resetBtn.addEventListener('click', animateReset);

    draw();
  </script>
</body>
</html>
