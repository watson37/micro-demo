<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Supply & Demand Demo (Scenarios + Check)</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:18px;color:#111;background:#f7f8fb}
    h1{font-size:20px;margin-bottom:6px}
    .row{display:flex;gap:18px;align-items:flex-start}
    .controls{width:360px}
    @media (max-width: 900px){.row{flex-direction:column}.controls{width:100%}}
    label{display:block;margin:10px 0 6px;font-weight:600}
    input[type=range]{width:100%}
    canvas{background:#ffffff;border:1px solid #e6e6e6;border-radius:8px;display:block}
    .muted{color:#666;font-size:13px;margin:0 0 10px}
    .small{color:#666;font-size:12px}
    .pcRow{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-top:8px}
    .pill{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;border-radius:999px;border:1px solid #e6e6e6;background:#fff;font-size:13px;cursor:pointer}
    .card{border:1px solid #e6e6e6;border-radius:10px;padding:12px;background:#fff}
    .topbar{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:6px}
    .resetBtn{
      width:36px;height:36px;border-radius:999px;border:1px solid #e6e6e6;
      background:#fff;cursor:pointer;font-size:16px;line-height:1;display:inline-flex;
      align-items:center;justify-content:center;transition:transform .12s ease, box-shadow .12s ease;
    }
    .resetBtn:hover{box-shadow:0 6px 18px rgba(0,0,0,.06);transform:translateY(-2px)}
    .resetBtn:active{transform:translateY(0px) scale(.98)}
    .stats{margin-top:10px;padding-top:10px;border-top:1px dashed #eee}
    .stat{margin:6px 0}
    .scenarioPanel{margin-top:10px;padding:10px;border-radius:8px;background:#fbfdff;border:1px solid #e6f0ff}
    select, button {font-family:inherit}
    .btn {padding:8px 10px;border-radius:8px;border:0;background:#0366d6;color:white;cursor:pointer}
    .btn.secondary {background:#6c757d}
    .feedback {margin-top:10px;padding:8px;border-radius:8px;background:#fff9e6;border:1px solid #ffe1a8;color:#7a5200}
    .feedback.pass {background:#e8ffef;border-color:#b8f0c9;color:#086937}
  </style>
</head>
<body>
  <h1>Interactive Supply & Demand Demo</h1>
  <p class="muted">Axes fixed at 0–100. Baseline (scenario) curve appears dashed when a scenario is started; your student-controlled curve moves above it. Use <b>Check answer</b> in Scenario Mode to grade attempts.</p>

  <div class="row">
    <div class="controls card">
      <div class="topbar">
        <div style="font-weight:700">Controls</div>
        <button id="resetBtn" class="resetBtn" title="Reset sliders to defaults">↺</button>
      </div>

      <div class="small" style="margin-bottom:8px;">Tip: set steepness to <b>0</b> for an effectively flat (perfectly elastic) curve; set it larger for steep / near-inelastic.</div>

      <label>Demand shift (higher = demand up / right)</label>
      <input id="dIntercept" type="range" min="-8" max="8" step="0.5" value="0">

      <label>Supply shift (higher = supply up / right)</label>
      <input id="sIntercept" type="range" min="-8" max="8" step="0.5" value="0">

      <label>Demand steepness (0 = flat / perfectly elastic)</label>
      <input id="dSlope" type="range" min="0" max="5" step="0.1" value="2">

      <label>Supply steepness (0 = flat / perfectly elastic)</label>
      <input id="sSlope" type="range" min="0" max="5" step="0.1" value="1.5">

      <hr style="border:none;border-top:1px solid #eee;margin:12px 0">

      <label>Price control slider (use only when you select Ceiling or Floor)</label>
      <input id="priceControl" type="range" min="0" max="100" step="1" value="50">
      <div class="pcRow" style="margin-top:8px">
        <label class="pill"><input id="pcNone" type="radio" name="pc" checked style="margin-right:6px"> None</label>
        <label class="pill"><input id="pcCeil" type="radio" name="pc" style="margin-right:6px"> Ceiling</label>
        <label class="pill"><input id="pcFloor" type="radio" name="pc" style="margin-right:6px"> Floor</label>
        <span class="pill">P = <span id="pcVal">—</span></span>
      </div>

      <div class="stats">
        <div class="stat"><strong>Equilibrium Price:</strong> <span id="peq">—</span></div>
        <div class="stat"><strong>Equilibrium Quantity:</strong> <span id="qeq">—</span></div>
        <div class="small" id="pcNote">No price control line selected.</div>
      </div>

      <hr style="border:none;border-top:1px solid #eee;margin:12px 0">

      <label><input id="scenarioToggle" type="checkbox" /> Scenario Mode</label>

      <div id="scenarioBox" class="scenarioPanel" style="display:none">
        <div style="display:flex;gap:8px;align-items:center;margin-bottom:8px">
          <select id="scenarioSelect" style="flex:1;padding:6px;border-radius:6px;border:1px solid #cfe6ff">
            <option value="demand_boom">Demand boom — strong demand shock</option>
            <option value="supply_shock">Supply shock — cost shock</option>
            <option value="productivity">Productivity jump — supply right</option>
            <option value="housing_slow">Housing slowdown — demand down</option>
            <option value="binding_ceiling">Binding ceiling — create shortage</option>
            <option value="binding_floor">Binding floor — create surplus</option>
          </select>
          <button id="startScenario" class="btn">Start scenario</button>
        </div>

        <div class="small" id="scenarioHint">Start a scenario to snapshot a baseline dashed curve, then adjust sliders (solid curve) to respond. Use Check Answer when ready.</div>

        <div style="display:flex;gap:8px;margin-top:10px">
          <button id="resetToScenario" class="btn secondary">Reset to scenario defaults</button>
          <button id="checkAnswer" class="btn">Check answer</button>
          <button id="exitScenario" class="btn secondary">Exit scenario</button>
        </div>

        <div id="feedback" style="display:none" class="feedback"></div>
      </div>

    </div>

    <div class="card" style="flex:1">
      <canvas id="chart" width="840" height="520"></canvas>
      <div class="small" style="margin-top:8px;">Baseline (scenario) curve is dashed & faint; student-controlled curve is solid. Equilibrium dotted crosshair shows the intersection.</div>
    </div>
  </div>

  <script>
    // ---- elements ----
    const canvas = document.getElementById('chart');
    const ctx = canvas.getContext('2d');

    const dInterceptEl = document.getElementById('dIntercept');
    const sInterceptEl = document.getElementById('sIntercept');
    const dSlopeEl = document.getElementById('dSlope');
    const sSlopeEl = document.getElementById('sSlope');

    const priceControlEl = document.getElementById('priceControl');
    const pcNone = document.getElementById('pcNone');
    const pcCeil = document.getElementById('pcCeil');
    const pcFloor = document.getElementById('pcFloor');
    const pcValEl = document.getElementById('pcVal');

    const peqEl = document.getElementById('peq');
    const qeqEl = document.getElementById('qeq');
    const pcNoteEl = document.getElementById('pcNote');

    const resetBtn = document.getElementById('resetBtn');

    const scenarioToggle = document.getElementById('scenarioToggle');
    const scenarioBox = document.getElementById('scenarioBox');
    const scenarioSelect = document.getElementById('scenarioSelect');
    const startScenarioBtn = document.getElementById('startScenario');
    const resetToScenarioBtn = document.getElementById('resetToScenario');
    const checkAnswerBtn = document.getElementById('checkAnswer');
    const exitScenarioBtn = document.getElementById('exitScenario');
    const feedbackEl = document.getElementById('feedback');

    // ---- constants & defaults ----
    const Q_MIN = 0, Q_MAX = 100;
    const P_MIN = 0, P_MAX = 100;

    const DEFAULTS = {
      dIntercept: 0,
      sIntercept: 0,
      dSlope: 2,
      sSlope: 1.5,
      priceControl: 50,
      pcMode: 'none'
    };

    // scenario presets plus simple "expectation" checks
    const SCENARIOS = {
      demand_boom: {
        name: 'Demand boom',
        desc: 'Demand shifts right strongly (higher intercept). Expect higher P and Q than baseline (by > 4).',
        values: { dIntercept: 6, sIntercept: 0, dSlope: 1.6, sSlope: 1.5, priceControl: 50, pcMode: 'none' },
        check: (baseline, student) => {
          // pass if student P > baseline P + 4
          return { pass: student.P > baseline.P + 4, hint: `Your P should be noticeably above the baseline (by ~4+). Baseline P=${baseline.P.toFixed(2)}.` };
        }
      },
      supply_shock: {
        name: 'Supply shock',
        desc: 'Supply shifts left / up in price. Expect P higher, Q lower vs baseline.',
        values: { dIntercept: 0, sIntercept: -6, dSlope: 2.2, sSlope: 2.2, priceControl: 50, pcMode: 'none' },
        check: (baseline, student) => {
          return { pass: (student.P > baseline.P + 3 && student.Q < baseline.Q - 3), hint: `Try raising price relative to baseline and expect quantity to fall.` };
        }
      },
      productivity: {
        name: 'Productivity jump',
        desc: 'Supply shifts right; expect P lower and Q higher vs baseline.',
        values: { dIntercept: 0, sIntercept: 6, dSlope: 2.0, sSlope: 1.6, priceControl: 50, pcMode: 'none' },
        check: (baseline, student) => {
          return { pass: (student.P < baseline.P - 3 && student.Q > baseline.Q + 3), hint: `Try lowering price relative to baseline and expect quantity to rise.` };
        }
      },
      housing_slow: {
        name: 'Housing slowdown',
        desc: 'Demand down (left), lowers P and Q.',
        values: { dIntercept: -5, sIntercept: 0, dSlope: 2.1, sSlope: 1.6, priceControl: 50, pcMode: 'none' },
        check: (baseline, student) => {
          return { pass: (student.P < baseline.P - 3 && student.Q < baseline.Q - 3), hint: `Demand down means lower P and lower Q than baseline.` };
        }
      },
      binding_ceiling: {
        name: 'Binding ceiling',
        desc: 'Set a ceiling below equilibrium to create a shortage.',
        values: { dIntercept: 2, sIntercept: 0, dSlope: 2.0, sSlope: 1.5, priceControl: 40, pcMode: 'ceiling' },
        check: (baseline, student, pc, studentQsAtPc, studentQdAtPc) => {
          const binding = (pc < baseline.P);
          const shortage = Math.max(0, studentQdAtPc - studentQsAtPc);
          return { pass: binding && shortage > 3, hint: binding ? `Shortage ≈ ${shortage.toFixed(2)} — try to make it >3 to be clearly binding.` : `Ceiling must be set below baseline price (${baseline.P.toFixed(2)}) to bind.`};
        }
      },
      binding_floor: {
        name: 'Binding floor',
        desc: 'Set a floor above equilibrium to create a surplus.',
        values: { dIntercept: 0, sIntercept: 2, dSlope: 2.0, sSlope: 1.5, priceControl: 70, pcMode: 'floor' },
        check: (baseline, student, pc, studentQsAtPc, studentQdAtPc) => {
          const binding = (pc > baseline.P);
          const surplus = Math.max(0, studentQsAtPc - studentQdAtPc);
          return { pass: binding && surplus > 3, hint: binding ? `Surplus ≈ ${surplus.toFixed(2)} — try to make it >3 to be clearly binding.` : `Floor must be set above baseline price (${baseline.P.toFixed(2)}) to bind.`};
        }
      }
    };

    // ---- state for scenario baseline vs student-controlled ----
    let scenarioActive = false;
    let activeScenarioKey = null;
    let baselineState = null;   // stored when scenario started
    let baselineEquil = null;   // {P, Q}
    // student curve uses current slider values (these are editable)

    // ---- helpers ----
    function clamp(x,a,b){ return Math.min(b, Math.max(a,x)); }

    function solveEquilibrium(state){
      // state: {dIntercept, sIntercept, dSlope, sSlope}
      const A_d = 80 + state.dIntercept*4;
      const A_s = 20 + state.sIntercept*4;
      const m_d = state.dSlope * 0.8;
      const m_s = state.sSlope * 0.8;
      let Q_eq = 50, P_eq = 50;
      const denom = (m_d + m_s);
      if(Math.abs(denom) < 1e-9){
        Q_eq = 50;
        P_eq = (A_d + A_s) / 2;
      } else {
        Q_eq = (A_d - A_s)/denom;
        P_eq = A_s + m_s * Q_eq;
      }
      Q_eq = clamp(Q_eq, Q_MIN, Q_MAX);
      P_eq = clamp(P_eq, P_MIN, P_MAX);
      return {P:P_eq, Q:Q_eq};
    }

    // P as function of Q for a given state
    function makePfunctions(state){
      const A_d = 80 + state.dIntercept*4;
      const A_s = 20 + state.sIntercept*4;
      const m_d = state.dSlope * 0.8;
      const m_s = state.sSlope * 0.8;
      return {
        P_d: (Q) => A_d - m_d * Q,
        P_s: (Q) => A_s + m_s * Q,
        invQd: (p) => (Math.abs(m_d) < 1e-9 ? (Math.abs(p - A_d)<1e-6 ? 50 : (p > A_d ? 0 : 100)) : (A_d - p)/m_d),
        invQs: (p) => (Math.abs(m_s) < 1e-9 ? (Math.abs(p - A_s)<1e-6 ? 50 : (p < A_s ? 0 : 100)) : (p - A_s)/m_s)
      };
    }

    // get state from sliders (student)
    function getState(){
      return {
        dIntercept: parseFloat(dInterceptEl.value),
        sIntercept: parseFloat(sInterceptEl.value),
        dSlope: parseFloat(dSlopeEl.value),
        sSlope: parseFloat(sSlopeEl.value),
        priceControl: parseFloat(priceControlEl.value),
        pcMode: pcCeil.checked ? 'ceiling' : (pcFloor.checked ? 'floor' : 'none')
      };
    }

    function setState(state){
      if('dIntercept' in state) dInterceptEl.value = state.dIntercept;
      if('sIntercept' in state) sInterceptEl.value = state.sIntercept;
      if('dSlope' in state) dSlopeEl.value = state.dSlope;
      if('sSlope' in state) sSlopeEl.value = state.sSlope;
      if('priceControl' in state) priceControlEl.value = state.priceControl;
      if('pcMode' in state){
        if(state.pcMode === 'ceiling') pcCeil.checked = true;
        else if(state.pcMode === 'floor') pcFloor.checked = true;
        else pcNone.checked = true;
      }
      draw();
    }

    // ---- drawing ----
    function draw(){
      // current (student) state
      const s = getState();

      // baseline functions (if scenarioActive, baselineState exists)
      let baselineFns = null;
      if(scenarioActive && baselineState){
        baselineFns = makePfunctions(baselineState);
      }

      // student functions
      const studentFns = makePfunctions(s);

      // equilibrium solve
      const studentEquil = solveEquilibrium(s);
      peqEl.textContent = studentEquil.P.toFixed(2);
      qeqEl.textContent = studentEquil.Q.toFixed(2);

      // canvas mapping
      const pad = 64;
      const w = canvas.width - pad*2;
      const h = canvas.height - pad*2;
      function xFromQ(q){ return pad + ((q - Q_MIN)/(Q_MAX - Q_MIN))*w; }
      function yFromP(p){ return pad + h - ((p - P_MIN)/(P_MAX - P_MIN))*h; }

      ctx.clearRect(0,0,canvas.width,canvas.height);

      // axis panel background
      ctx.fillStyle = '#ffffff';
      ctx.fillRect(pad-6, pad-6, w+12, h+12);

      // grid lines and ticks
      ctx.strokeStyle = '#e6e9ef'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(pad, pad+h); ctx.lineTo(pad+w, pad+h); ctx.moveTo(pad, pad); ctx.lineTo(pad, pad+h); ctx.stroke();
      ctx.font = '11px system-ui'; ctx.fillStyle = '#213547';
      ctx.strokeStyle = 'rgba(33,53,71,0.04)';
      for(let t=0;t<=5;t++){
        const q = t*20; const x = xFromQ(q);
        ctx.beginPath(); ctx.moveTo(x, pad); ctx.lineTo(x, pad+h); ctx.stroke();
        ctx.fillStyle = '#213547'; ctx.fillText(q.toString(), x-8, pad+h+18);
      }
      for(let t=0;t<=5;t++){
        const p = t*20; const y = yFromP(p);
        ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(pad+w, y); ctx.stroke();
        ctx.fillStyle = '#213547'; ctx.fillText(p.toString(), pad-36, y+4);
      }

      // helper to plot curve but optionally dashed/faint (for baseline)
      function plotCurve(PofQ, color, dashed=false, alpha=1.0){
        ctx.save();
        ctx.strokeStyle = color;
        ctx.globalAlpha = alpha;
        ctx.lineWidth = 3;
        if(dashed) ctx.setLineDash([6,6]);
        let drawing = false;
        ctx.beginPath();
        const steps = 300;
        for(let i=0;i<=steps;i++){
          const Q = Q_MIN + (i/steps)*(Q_MAX - Q_MIN);
          const P = PofQ(Q);
          const inside = (P >= P_MIN && P <= P_MAX);
          if(inside){
            const x = xFromQ(Q), y = yFromP(P);
            if(!drawing){ ctx.moveTo(x,y); drawing = true; } else { ctx.lineTo(x,y); }
          } else {
            drawing = false;
          }
        }
        ctx.stroke();
        ctx.restore();
      }

      // draw baseline curves first (dashed faint)
      if(baselineFns){
        plotCurve(baselineFns.P_d, '#ffb7b7', true, 0.65); // demand baseline, light red dashed
        plotCurve(baselineFns.P_s, '#bfeadf', true, 0.65); // supply baseline, light green dashed
      }

      // draw student curves (solid)
      plotCurve(studentFns.P_d, '#ff6b6b', false, 1.0);
      plotCurve(studentFns.P_s, '#37b98a', false, 1.0);

      // equilibrium dotted crosshair for student curve
      const xe = xFromQ(studentEquil.Q), ye = yFromP(studentEquil.P);
      ctx.setLineDash([6,6]);
      ctx.strokeStyle = 'rgba(33,53,71,0.14)'; ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(pad, ye); ctx.lineTo(xe, ye); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(xe, pad+h); ctx.lineTo(xe, ye); ctx.stroke();
      ctx.setLineDash([]);

      // equilibrium marker
      ctx.fillStyle = '#111';
      ctx.beginPath(); ctx.arc(xe, ye, 5, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#fff'; ctx.font = '12px system-ui'; ctx.fillText('E', xe+8, ye-8);

      // price control logic
      const mode = pcCeil.checked ? 'ceiling' : (pcFloor.checked ? 'floor' : 'none');
      const pc = parseFloat(priceControlEl.value);
      pcValEl.textContent = (mode === 'none') ? '—' : pc.toFixed(0);

      if(mode !== 'none'){
        const ypc = yFromP(pc);
        ctx.setLineDash([6,6]);
        ctx.strokeStyle = (mode === 'ceiling') ? '#f4b400' : '#34a853';
        ctx.lineWidth = 2; ctx.beginPath(); ctx.moveTo(pad, ypc); ctx.lineTo(pad+w, ypc); ctx.stroke();
        ctx.setLineDash([]);

        // quantities at price pc for student curves
        let QdAtPc = studentFns.invQd(pc);
        let QsAtPc = studentFns.invQs(pc);
        QdAtPc = clamp(QdAtPc, Q_MIN, Q_MAX);
        QsAtPc = clamp(QsAtPc, Q_MIN, Q_MAX);

        // mark Qd, Qs
        function markPoint(Q, p, color, label){
          if(p < P_MIN || p > P_MAX) return;
          const x = xFromQ(Q), y = yFromP(p);
          ctx.fillStyle = color; ctx.beginPath(); ctx.arc(x,y,5,0,Math.PI*2); ctx.fill();
          ctx.fillStyle = '#fff'; ctx.font='12px system-ui'; ctx.fillText(label, x+8, y-8);
        }
        markPoint(QdAtPc, pc, '#ff6b6b', 'QD');
        markPoint(QsAtPc, pc, '#37b98a', 'QS');

        if(mode === 'ceiling'){
          const binding = pc < studentEquil.P;
          if(binding){
            const shortage = Math.max(0, QdAtPc - QsAtPc);
            pcNoteEl.textContent = `Binding ceiling (P=${pc.toFixed(0)}): shortage ≈ ${shortage.toFixed(2)} (QD - QS at the controlled price).`;
          } else {
            pcNoteEl.textContent = 'Non-binding ceiling: market stays at equilibrium.';
          }
        } else {
          const binding = pc > studentEquil.P;
          if(binding){
            const surplus = Math.max(0, QsAtPc - QdAtPc);
            pcNoteEl.textContent = `Binding floor (P=${pc.toFixed(0)}): surplus ≈ ${surplus.toFixed(2)} (QS - QD at the controlled price).`;
          } else {
            pcNoteEl.textContent = 'Non-binding floor: market stays at equilibrium.';
          }
        }
      } else {
        pcNoteEl.textContent = 'No price control line selected.';
      }
    }

    // ---- reset animation (snaps sliders to defaults) ----
    function animateReset(){
      const start = getState();
      const end = DEFAULTS;
      const dur = 320;
      const t0 = performance.now();
      function ease(x){ return 1 - Math.pow(1-x,3); }

      function frame(now){
        const u = clamp((now - t0)/dur, 0, 1);
        const e = ease(u);
        const cur = {
          dIntercept: start.dIntercept + (end.dIntercept - start.dIntercept)*e,
          sIntercept: start.sIntercept + (end.sIntercept - start.sIntercept)*e,
          dSlope: start.dSlope + (end.dSlope - start.dSlope)*e,
          sSlope: start.sSlope + (end.sSlope - start.sSlope)*e,
          priceControl: start.priceControl + (end.priceControl - start.priceControl)*e,
          pcMode: (u < 1) ? start.pcMode : end.pcMode
        };
        setState(cur);
        if(u < 1) requestAnimationFrame(frame);
        else { setState(end); }
      }
      requestAnimationFrame(frame);
    }

    // ---- scenario lifecycle ----
    function showScenarioBox(show){
      scenarioBox.style.display = show ? 'block' : 'none';
    }

    function startScenario(key){
      const sc = SCENARIOS[key];
      if(!sc) return;
      activeScenarioKey = key;
      scenarioActive = true;
      // set baseline to scenario's values and snapshot baseline equilibrium
      baselineState = Object.assign({}, sc.values);
      baselineEquil = solveEquilibrium(baselineState);
      // place student's sliders initially at baseline (they move the student curve)
      setState(Object.assign({}, baselineState));
      feedbackEl.style.display = 'none';
      draw();
      document.getElementById('scenarioHint').textContent = sc.name + ' — ' + sc.desc;
    }

    function resetToScenarioDefaults(){
      if(!scenarioActive || !baselineState) return;
      setState(baselineState);
      feedbackEl.style.display = 'none';
    }

    function exitScenario(){
      scenarioActive = false;
      activeScenarioKey = null;
      baselineState = null;
      baselineEquil = null;
      feedbackEl.style.display = 'none';
      // return to defaults (free play) but keep current sliders as they are
      setState(DEFAULTS);
    }

    function checkAnswer(){
      if(!scenarioActive || !activeScenarioKey){ feedbackEl.style.display = 'block'; feedbackEl.className='feedback'; feedbackEl.textContent = 'Start a scenario to check an answer.'; return; }
      const sc = SCENARIOS[activeScenarioKey];
      const baseline = baselineEquil || solveEquilibrium(baselineState);
      const studentState = getState();
      const studentEquil = solveEquilibrium(studentState);

      // for price control scenarios we need Qd/Qs at pc for student's curves
      const studentFns = makePfunctions(studentState);
      const pc = studentState.priceControl;
      const studentQdAtPc = clamp(studentFns.invQd(pc), Q_MIN, Q_MAX);
      const studentQsAtPc = clamp(studentFns.invQs(pc), Q_MIN, Q_MAX);

      let result;
      try{
        result = sc.check(baseline, studentEquil, pc, studentQsAtPc, studentQdAtPc);
      }catch(e){
        result = { pass: false, hint: 'Scenario check not configured.'};
      }

      feedbackEl.style.display = 'block';
      if(result.pass){
        feedbackEl.className = 'feedback pass';
        feedbackEl.textContent = 'Nice! PASS — ' + (result.hint || 'Good job.');
      } else {
        feedbackEl.className = 'feedback';
        feedbackEl.textContent = 'Not quite — ' + (result.hint || 'Try adjusting sliders to better satisfy the scenario.');
      }
    }

    // ---- events ----
    [dInterceptEl, sInterceptEl, dSlopeEl, sSlopeEl, priceControlEl].forEach(el=>{
      el.addEventListener('input', draw);
      el.addEventListener('change', draw);
    });
    [pcNone, pcCeil, pcFloor].forEach(el=>{ el.addEventListener('change', draw); });

    resetBtn.addEventListener('click', ()=>{ animateReset(); });

    scenarioToggle.addEventListener('change', (e)=>{ showScenarioBox(e.target.checked); });

    startScenarioBtn.addEventListener('click', ()=>{
      const key = scenarioSelect.value;
      startScenario(key);
    });

    resetToScenarioBtn.addEventListener('click', (e)=>{
      resetToScenarioDefaults();
    });

    exitScenarioBtn.addEventListener('click', (e)=>{
      exitScenario();
    });

    checkAnswerBtn.addEventListener('click', (e)=>{
      checkAnswer();
    });

    // initialize
    setState(DEFAULTS);
    draw();

    // ensure canvas pixels match layout size (avoid HiDPI mis-scaling)
    (function fixCanvasSize(){
      const styleW = canvas.clientWidth || 840;
      const styleH = canvas.clientHeight || 520;
      canvas.width = styleW;
      canvas.height = styleH;
      draw();
    })();

    window.addEventListener('resize', ()=>{
      const styleW = canvas.clientWidth || 840;
      const styleH = canvas.clientHeight || 520;
      canvas.width = styleW;
      canvas.height = styleH;
      draw();
    });
  </script>
</body>
</html>
