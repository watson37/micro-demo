<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Supply & Demand Demo</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:18px;color:#111}
    h1{font-size:20px;margin-bottom:6px}
    .row{display:flex;gap:18px;align-items:flex-start}
    .controls{width:340px}
    label{display:block;margin:10px 0 6px;font-weight:600}
    input[type=range]{width:100%}
    canvas{background:#fbfbfb;border:1px solid #e6e6e6;border-radius:8px}
    .info{margin-top:12px}
    .stat{margin:6px 0}
    .muted{color:#666;font-size:13px;line-height:1.35}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #e6e6e6;background:#fff;font-size:12px;color:#444}
    .divider{margin:12px 0;border-top:1px solid #eee}
    .pcRow{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .pcRow label{margin:0;font-weight:600}
    .tiny{font-size:12px;color:#666}
  </style>
</head>
<body>
  <h1>Interactive Supply & Demand Demo</h1>
  <p class="muted">Shift demand and supply, change steepness all the way to perfectly inelastic (vertical) or perfectly elastic (horizontal), and add a price line to visualize ceilings/floors and shortages/surpluses.</p>

  <div class="row">
    <div class="controls">

      <label>Demand shift (right for normal demand, up/down if perfectly elastic)</label>
      <input id="dShift" type="range" min="-8" max="8" step="0.5" value="0">
      <div class="tiny"><span class="pill" id="dShiftTag">0.0</span></div>

      <label>Supply shift (right for normal supply, up/down if perfectly elastic)</label>
      <input id="sShift" type="range" min="-8" max="8" step="0.5" value="0">
      <div class="tiny"><span class="pill" id="sShiftTag">0.0</span></div>

      <label>Demand steepness (0 = perfectly inelastic, 100 = perfectly elastic)</label>
      <input id="dSteep" type="range" min="0" max="100" step="1" value="55">
      <div class="tiny"><span class="pill" id="dSteepTag">55</span></div>

      <label>Supply steepness (0 = perfectly inelastic, 100 = perfectly elastic)</label>
      <input id="sSteep" type="range" min="0" max="100" step="1" value="45">
      <div class="tiny"><span class="pill" id="sSteepTag">45</span></div>

      <div class="divider"></div>

      <label>Price line</label>
      <div class="pcRow">
        <label class="tiny"><input type="radio" name="pc" id="pcNone" checked> None</label>
        <label class="tiny"><input type="radio" name="pc" id="pcCeiling"> Ceiling</label>
        <label class="tiny"><input type="radio" name="pc" id="pcFloor"> Floor</label>
      </div>

      <div style="margin-top:10px">
        <input id="pcPrice" type="range" min="0" max="40" step="0.25" value="12">
        <div class="tiny"><span class="pill" id="pcPriceTag">P = 12.00</span></div>
      </div>

      <div class="info">
        <div class="stat"><strong>Equilibrium Price:</strong> <span id="peq">—</span></div>
        <div class="stat"><strong>Equilibrium Quantity:</strong> <span id="qeq">—</span></div>
        <div class="stat"><strong>Price control result:</strong> <span id="pcResult">None</span></div>
      </div>

      <p class="muted">
        Quick interpretation:
        <br>• Inelastic (0) = vertical curve (Q doesn’t respond to price)
        <br>• Elastic (100) = horizontal curve (P doesn’t respond to quantity)
      </p>
    </div>

    <canvas id="chart" width="720" height="480"></canvas>
  </div>

  <script>
    const canvas = document.getElementById('chart');
    const ctx = canvas.getContext('2d');

    const dShiftEl = document.getElementById('dShift');
    const sShiftEl = document.getElementById('sShift');
    const dSteepEl = document.getElementById('dSteep');
    const sSteepEl = document.getElementById('sSteep');

    const dShiftTag = document.getElementById('dShiftTag');
    const sShiftTag = document.getElementById('sShiftTag');
    const dSteepTag = document.getElementById('dSteepTag');
    const sSteepTag = document.getElementById('sSteepTag');

    const peqEl = document.getElementById('peq');
    const qeqEl = document.getElementById('qeq');

    const pcNone = document.getElementById('pcNone');
    const pcCeiling = document.getElementById('pcCeiling');
    const pcFloor = document.getElementById('pcFloor');
    const pcPrice = document.getElementById('pcPrice');
    const pcPriceTag = document.getElementById('pcPriceTag');
    const pcResult = document.getElementById('pcResult');

    function clamp(x,a,b){ return Math.min(b, Math.max(a,x)); }

    function isPerfectElastic(v){ return parseFloat(v) >= 100; }

    // Map steepness slider to slope coefficient B:
    // 0 => 0 (perfectly inelastic vertical)
    // 100 => huge (approx perfectly elastic horizontal)
    function mapSteepToB(v){
      const x = parseFloat(v);
      if(x <= 0) return 0;
      if(x >= 100) return 1e6;
      const t = x / 100;
      const shaped = Math.pow(t, 3.2);
      return 0.2 + shaped * 120;
    }

    function draw(){
      const d0 = parseFloat(dShiftEl.value);
      const s0 = parseFloat(sShiftEl.value);

      const demandIsFlat = isPerfectElastic(dSteepEl.value);
      const supplyIsFlat = isPerfectElastic(sSteepEl.value);

      const Bd = mapSteepToB(dSteepEl.value);
      const Bs = mapSteepToB(sSteepEl.value);

      // Base intercept-style shifts for normal (non-flat) curves
      // Demand: Qd = Ad - Bd*P
      // Supply: Qs = As + Bs*P
      const Ad = 56 + d0*4;
      const As = 10 + s0*3;

      // For perfectly elastic curves, interpret "shift" as up/down in price level:
      // Demand horizontal line P = Pd_flat (higher shift => higher willingness to pay)
      // Supply horizontal line P = Ps_flat (higher shift => lower cost => lower price)
      const Pd_flat = 18 + d0*1.2;
      const Ps_flat = 10 - s0*1.0;

      // Solve equilibrium in a way that respects vertical/horizontal special cases
      let P_eq = NaN;
      let Q_eq = NaN;

      if(demandIsFlat && supplyIsFlat){
        if(Math.abs(Pd_flat - Ps_flat) < 1e-6){
          P_eq = Pd_flat;
          Q_eq = 50; // display point only
        } else {
          P_eq = NaN;
          Q_eq = NaN;
        }
      } else if(demandIsFlat){
        P_eq = Pd_flat;
        Q_eq = (Bs === 0) ? As : (As + Bs * P_eq);
      } else if(supplyIsFlat){
        P_eq = Ps_flat;
        Q_eq = (Bd === 0) ? Ad : (Ad - Bd * P_eq);
      } else if(Bd === 0 && Bs === 0){
        P_eq = NaN;
        Q_eq = (Ad + As) / 2;
      } else {
        P_eq = (Ad - As) / (Bd + Bs);
        Q_eq = Ad - Bd * P_eq;
      }

      // UI values
      peqEl.textContent = Number.isFinite(P_eq) ? P_eq.toFixed(2) : '—';
      qeqEl.textContent = Number.isFinite(Q_eq) ? Q_eq.toFixed(2) : '—';

      // Chart bounds
      const pad = 60;
      const w = canvas.width - pad*2;
      const h = canvas.height - pad*2;

      const qtyMax = clamp(Math.max(70, Ad*1.15, (As + 30)), 70, 160);

      let priceMax = 40;
      if(Number.isFinite(P_eq) && P_eq > 0) priceMax = clamp(P_eq * 1.8, 20, 60);
      // also ensure flat-line levels are visible
      priceMax = Math.max(priceMax, Pd_flat + 8, Ps_flat + 8);

      function xFromQ(q){ return pad + (q/qtyMax)*w; }
      function yFromP(p){ return pad + h - (p/priceMax)*h; }

      // Clear
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // Axes
      ctx.strokeStyle = '#222';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(pad, pad+h); ctx.lineTo(pad+w, pad+h);
      ctx.moveTo(pad, pad);   ctx.lineTo(pad, pad+h+6);
      ctx.stroke();

      // Axis labels
      ctx.fillStyle='#333';
      ctx.font='12px system-ui';
      ctx.fillText('Quantity', pad + w - 48, pad + h + 30);
      ctx.save();
      ctx.translate(pad-40, pad+20);
      ctx.rotate(-Math.PI/2);
      ctx.fillText('Price', 0, 0);
      ctx.restore();

      // Helper to draw curve by parameterizing over price
      function drawCurve(getQ, strokeStyle){
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = 3;
        ctx.beginPath();
        for(let i=0;i<=220;i++){
          const t = i/220;
          const P = t*priceMax;
          const Q = getQ(P);
          const x = xFromQ(clamp(Q, 0, qtyMax));
          const y = yFromP(P);
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();
      }

      // Draw Demand
      if(demandIsFlat){
        ctx.strokeStyle = '#d64545';
        ctx.lineWidth = 3;
        const y = yFromP(Pd_flat);
        ctx.beginPath();
        ctx.moveTo(pad, y);
        ctx.lineTo(pad+w, y);
        ctx.stroke();
      } else if(Bd === 0){
        ctx.strokeStyle = '#d64545';
        ctx.lineWidth = 3;
        const x = xFromQ(clamp(Ad, 0, qtyMax));
        ctx.beginPath();
        ctx.moveTo(x, yFromP(0));
        ctx.lineTo(x, yFromP(priceMax));
        ctx.stroke();
      } else {
        drawCurve((P)=> (Ad - Bd*P), '#d64545');
      }

      // Draw Supply
      if(supplyIsFlat){
        ctx.strokeStyle = '#2a9d8f';
        ctx.lineWidth = 3;
        const y = yFromP(Ps_flat);
        ctx.beginPath();
        ctx.moveTo(pad, y);
        ctx.lineTo(pad+w, y);
        ctx.stroke();
      } else if(Bs === 0){
        ctx.strokeStyle = '#2a9d8f';
        ctx.lineWidth = 3;
        const x = xFromQ(clamp(As, 0, qtyMax));
        ctx.beginPath();
        ctx.moveTo(x, yFromP(0));
        ctx.lineTo(x, yFromP(priceMax));
        ctx.stroke();
      } else {
        drawCurve((P)=> (As + Bs*P), '#2a9d8f');
      }

      // Legends
      ctx.fillStyle='#d64545'; ctx.fillRect(canvas.width-150, pad-8, 12, 8);
      ctx.fillStyle='#333'; ctx.fillText('Demand', canvas.width-132, pad);
      ctx.fillStyle='#2a9d8f'; ctx.fillRect(canvas.width-150, pad+12, 12, 8);
      ctx.fillStyle='#333'; ctx.fillText('Supply', canvas.width-132, pad+20);

      // Equilibrium marker + dotted tracking lines
      if(Number.isFinite(P_eq) && Number.isFinite(Q_eq)){
        const xe = xFromQ(Q_eq);
        const ye = yFromP(P_eq);

        ctx.save();
        ctx.setLineDash([4,4]);
        ctx.strokeStyle='rgba(0,0,0,0.18)';
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.moveTo(pad, ye); ctx.lineTo(xe, ye);
        ctx.moveTo(xe, pad+h); ctx.lineTo(xe, ye);
        ctx.stroke();
        ctx.restore();

        ctx.fillStyle = 'black';
        ctx.beginPath(); ctx.arc(xe, ye, 5, 0, Math.PI*2); ctx.fill();
        ctx.font = '13px system-ui';
        ctx.fillText('E', xe+8, ye-8);

        ctx.fillStyle='#555'; ctx.font='11px system-ui';
        ctx.fillText(P_eq.toFixed(2), pad-50, ye+4);
        ctx.fillText(Q_eq.toFixed(2), xe-12, pad+h+18);
      }

      // Price line controls
      const pcP = parseFloat(pcPrice.value);
      pcPriceTag.textContent = 'P = ' + pcP.toFixed(2);

      const mode = pcCeiling.checked ? 'ceiling' : (pcFloor.checked ? 'floor' : 'none');

      // Compute Qd and Qs at the control price
      // For flat demand/supply, interpret as "available any quantity at that price" with a simple step:
      // demand: if price <= Pd_flat => huge QD, else ~0
      // supply: if price >= Ps_flat => huge QS, else ~0
      let Qd_at;
      if(demandIsFlat){
        Qd_at = (pcP <= Pd_flat) ? qtyMax : 0;
      } else if(Bd === 0){
        Qd_at = Ad;
      } else {
        Qd_at = Ad - Bd*pcP;
      }

      let Qs_at;
      if(supplyIsFlat){
        Qs_at = (pcP >= Ps_flat) ? qtyMax : 0;
      } else if(Bs === 0){
        Qs_at = As;
      } else {
        Qs_at = As + Bs*pcP;
      }

      Qd_at = clamp(Qd_at, 0, qtyMax);
      Qs_at = clamp(Qs_at, 0, qtyMax);

      // Draw price line + intersection points + shortage/surplus bracket if binding
      if(mode !== 'none'){
        const yLine = yFromP(pcP);

        // price line
        ctx.save();
        ctx.setLineDash([6,6]);
        ctx.lineWidth = 2;
        ctx.strokeStyle = (mode === 'ceiling') ? 'rgba(255, 170, 0, 0.95)' : 'rgba(30, 140, 90, 0.95)';
        ctx.beginPath();
        ctx.moveTo(pad, yLine);
        ctx.lineTo(pad+w, yLine);
        ctx.stroke();
        ctx.restore();

        // intersection points
        const xQD = xFromQ(Qd_at);
        const xQS = xFromQ(Qs_at);

        ctx.save();

        // dots on the price line
        ctx.fillStyle = '#d64545';
        ctx.beginPath(); ctx.arc(xQD, yLine, 5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#2a9d8f';
        ctx.beginPath(); ctx.arc(xQS, yLine, 5, 0, Math.PI*2); ctx.fill();

        // dotted drop lines to axis
        ctx.setLineDash([4,4]);
        ctx.strokeStyle = 'rgba(0,0,0,0.18)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(xQD, pad+h); ctx.lineTo(xQD, yLine);
        ctx.moveTo(xQS, pad+h); ctx.lineTo(xQS, yLine);
        ctx.stroke();
        ctx.setLineDash([]);

        // binding + bracket label (only if equilibrium exists)
        if(Number.isFinite(P_eq)){
          const binding = (mode === 'ceiling') ? (pcP < P_eq) : (pcP > P_eq);

          if(binding){
            const left = Math.min(xQD, xQS);
            const right = Math.max(xQD, xQS);

            let label = '';
            if(mode === 'ceiling'){
              const shortage = Math.max(0, Qd_at - Qs_at);
              label = `Shortage ≈ ${shortage.toFixed(2)}`;
            } else {
              const surplus = Math.max(0, Qs_at - Qd_at);
              label = `Surplus ≈ ${surplus.toFixed(2)}`;
            }

            ctx.strokeStyle = 'rgba(0,0,0,0.55)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(left, yLine - 14); ctx.lineTo(right, yLine - 14);
            ctx.moveTo(left, yLine - 20); ctx.lineTo(left, yLine - 8);
            ctx.moveTo(right, yLine - 20); ctx.lineTo(right, yLine - 8);
            ctx.stroke();

            ctx.fillStyle = '#333';
            ctx.font = '12px system-ui';
            ctx.fillText(label, left + 6, yLine - 20);
          }
        }

        ctx.restore();
      }

      // Price control result text
      if(!Number.isFinite(P_eq) || !Number.isFinite(Q_eq)){
        if(mode === 'none'){
          pcResult.textContent = 'None';
        } else {
          pcResult.textContent = 'Equilibrium is not unique/defined in this extreme configuration, but you can still see QD and QS at the chosen price line.';
        }
      } else {
        if(mode === 'none'){
          pcResult.textContent = 'None';
        } else {
          const binding = (mode === 'ceiling') ? (pcP < P_eq) : (pcP > P_eq);

          if(!binding){
            pcResult.textContent = (mode === 'ceiling')
              ? 'Ceiling is non-binding. Market stays at equilibrium.'
              : 'Floor is non-binding. Market stays at equilibrium.';
          } else {
            if(mode === 'ceiling'){
              const shortage = Math.max(0, Qd_at - Qs_at);
              const traded = Qs_at;
              pcResult.textContent = `Binding ceiling. Quantity traded limited by supply ≈ ${traded.toFixed(2)}. Shortage ≈ ${shortage.toFixed(2)}.`;
            } else {
              const surplus = Math.max(0, Qs_at - Qd_at);
              const traded = Qd_at;
              pcResult.textContent = `Binding floor. Quantity traded limited by demand ≈ ${traded.toFixed(2)}. Surplus ≈ ${surplus.toFixed(2)}.`;
            }
          }
        }
      }

      // Slider tags
      dShiftTag.textContent = d0.toFixed(1);
      sShiftTag.textContent = s0.toFixed(1);
      dSteepTag.textContent = dSteepEl.value;
      sSteepTag.textContent = sSteepEl.value;
    }

    // Events
    [dShiftEl, sShiftEl, dSteepEl, sSteepEl, pcPrice, pcNone, pcCeiling, pcFloor].forEach(el=>{
      el.addEventListener('input', draw);
      el.addEventListener('change', draw);
    });

    draw();
  </script>
</body>
</html>
