<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Interactive Supply & Demand Demo</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;margin:18px;color:#111}
    h1{font-size:20px;margin-bottom:6px}
    .row{display:flex;gap:18px;align-items:flex-start}
    .controls{width:340px}
    label{display:block;margin:10px 0 6px;font-weight:600}
    input[type=range]{width:100%}
    canvas{background:#fbfbfb;border:1px solid #e6e6e6;border-radius:8px}
    .info{margin-top:12px}
    .stat{margin:6px 0}
    .muted{color:#666;font-size:13px;line-height:1.35}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;border:1px solid #e6e6e6;background:#fff;font-size:12px;color:#444}
    .divider{margin:12px 0;border-top:1px solid #eee}
    .pcRow{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .pcRow label{margin:0;font-weight:600}
    .tiny{font-size:12px;color:#666}
  </style>
</head>
<body>
  <h1>Interactive Supply & Demand Demo</h1>
  <p class="muted">Move the sliders to shift curves, change how steep or flat they are, and watch equilibrium update. Use the price line to test ceilings and floors.</p>

  <div class="row">
    <div class="controls">

      <label>Demand shift (right = higher demand)</label>
      <input id="dIntercept" type="range" min="-8" max="8" step="0.5" value="0">
      <div class="tiny"><span class="pill" id="dShiftTag">0.0</span></div>

      <label>Supply shift (right = higher supply)</label>
      <input id="sIntercept" type="range" min="-8" max="8" step="0.5" value="0">
      <div class="tiny"><span class="pill" id="sShiftTag">0.0</span></div>

      <label>Demand steepness (0 = perfectly inelastic, 100 = perfectly elastic)</label>
      <input id="dSteep" type="range" min="0" max="100" step="1" value="55">
      <div class="tiny"><span class="pill" id="dSteepTag">55</span></div>

      <label>Supply steepness (0 = perfectly inelastic, 100 = perfectly elastic)</label>
      <input id="sSteep" type="range" min="0" max="100" step="1" value="45">
      <div class="tiny"><span class="pill" id="sSteepTag">45</span></div>

      <div class="divider"></div>

      <label>Price line</label>
      <div class="pcRow">
        <label class="tiny"><input type="radio" name="pc" id="pcNone" checked> None</label>
        <label class="tiny"><input type="radio" name="pc" id="pcCeiling"> Ceiling</label>
        <label class="tiny"><input type="radio" name="pc" id="pcFloor"> Floor</label>
      </div>

      <div style="margin-top:10px">
        <input id="pcPrice" type="range" min="0" max="40" step="0.25" value="12">
        <div class="tiny"><span class="pill" id="pcPriceTag">P = 12.00</span></div>
      </div>

      <div class="info">
        <div class="stat"><strong>Equilibrium Price:</strong> <span id="peq">—</span></div>
        <div class="stat"><strong>Equilibrium Quantity:</strong> <span id="qeq">—</span></div>
        <div class="stat"><strong>Price control result:</strong> <span id="pcResult">None</span></div>
      </div>

      <p class="muted">
        Notes for students:
        <br>• Perfectly inelastic means quantity does not change when price changes (vertical curve).
        <br>• Perfectly elastic means price does not change when quantity changes (horizontal curve).
      </p>
    </div>

    <canvas id="chart" width="720" height="480"></canvas>
  </div>

  <script>
    // Linear supply & demand with extreme steepness options.
    // Demand: Qd = Ad - Bd*P
    // Supply: Qs = As + Bs*P
    //
    // In P vs Q space:
    // - Bd = 0 => Qd constant => vertical demand (perfectly inelastic)
    // - Bd very large => P barely changes with Q => near horizontal (perfectly elastic)
    //
    // Same idea for supply via Bs.

    const canvas = document.getElementById('chart');
    const ctx = canvas.getContext('2d');

    const dInterceptEl = document.getElementById('dIntercept');
    const sInterceptEl = document.getElementById('sIntercept');
    const dSteepEl = document.getElementById('dSteep');
    const sSteepEl = document.getElementById('sSteep');

    const dShiftTag = document.getElementById('dShiftTag');
    const sShiftTag = document.getElementById('sShiftTag');
    const dSteepTag = document.getElementById('dSteepTag');
    const sSteepTag = document.getElementById('sSteepTag');

    const peqEl = document.getElementById('peq');
    const qeqEl = document.getElementById('qeq');

    const pcNone = document.getElementById('pcNone');
    const pcCeiling = document.getElementById('pcCeiling');
    const pcFloor = document.getElementById('pcFloor');
    const pcPrice = document.getElementById('pcPrice');
    const pcPriceTag = document.getElementById('pcPriceTag');
    const pcResult = document.getElementById('pcResult');

    function clamp(x,a,b){ return Math.min(b, Math.max(a,x)); }

    // Map steepness slider (0..100) to slope coefficient B
    // 0 => exactly 0 (perfectly inelastic vertical)
    // 100 => huge (approx perfectly elastic horizontal)
    function mapSteepToB(v){
      const x = parseFloat(v);
      if(x <= 0) return 0;
      if(x >= 100) return 1e6;

      // Smooth curve: small changes near 0 still visible, but ramps a lot near 100
      // This makes 100 behave like "infinite" without breaking math.
      const t = x / 100;                 // 0..1
      const shaped = Math.pow(t, 3.2);   // emphasize extremes
      return 0.2 + shaped * 120;         // typical range 0.2..120, then 1e6 at 100
    }

    function draw(){
      const d0 = parseFloat(dInterceptEl.value);
      const s0 = parseFloat(sInterceptEl.value);

      const Bd = mapSteepToB(dSteepEl.value);
      const Bs = mapSteepToB(sSteepEl.value);

      // Base intercepts (shifted)
      const Ad = 56 + d0*4;    // demand intercept
      const As = 10 + s0*3;    // supply intercept

      // Solve equilibrium.
      // If both Bd and Bs are 0, the system is vertical vs vertical and no unique P. We'll handle that.
      let P_eq = NaN;
      let Q_eq = NaN;

      if(Bd === 0 && Bs === 0){
        // Both perfectly inelastic: quantities are fixed (Qd=Ad, Qs=As). No single market-clearing price.
        // We'll show "—" for P and pick Q where they "meet" conceptually (average) just for plotting a point.
        Q_eq = (Ad + As) / 2;
      } else {
        // Ad - Bd*P = As + Bs*P  => P*(Bd+Bs) = Ad - As
        P_eq = (Ad - As) / (Bd + Bs);
        Q_eq = Ad - Bd*P_eq;
      }

      // Display equilibrium values
      peqEl.textContent = Number.isFinite(P_eq) ? P_eq.toFixed(2) : '—';
      qeqEl.textContent = Number.isFinite(Q_eq) ? Q_eq.toFixed(2) : '—';

      // Chart scaling
      const pad = 60;
      const w = canvas.width - pad*2;
      const h = canvas.height - pad*2;

      // Choose reasonable plot bounds
      const qtyMax = clamp(Math.max(70, Ad*1.15, (As + 30)), 70, 140);
      let priceMax = 40;

      // if equilibrium price is finite and positive, use it to scale nicely
      if(Number.isFinite(P_eq) && P_eq > 0){
        priceMax = clamp(P_eq * 1.8, 20, 60);
      }

      function xFromQ(q){ return pad + (q/qtyMax)*w; }
      function yFromP(p){ return pad + h - (p/priceMax)*h; }

      // Clear
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // Axes
      ctx.strokeStyle = '#222';
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(pad, pad+h); ctx.lineTo(pad+w, pad+h); // x axis
      ctx.moveTo(pad, pad);   ctx.lineTo(pad, pad+h+6); // y axis
      ctx.stroke();

      // Axis labels
      ctx.fillStyle='#333';
      ctx.font='12px system-ui';
      ctx.fillText('Quantity', pad + w - 48, pad + h + 30);
      ctx.save();
      ctx.translate(pad-40, pad+20);
      ctx.rotate(-Math.PI/2);
      ctx.fillText('Price', 0, 0);
      ctx.restore();

      // Helper: draw a curve by parameterizing over price
      function drawCurve(getQ, strokeStyle){
        ctx.strokeStyle = strokeStyle;
        ctx.lineWidth = 3;
        ctx.beginPath();
        for(let i=0;i<=220;i++){
          const t = i/220;
          const P = t*priceMax;
          const Q = getQ(P);
          const x = xFromQ(clamp(Q, 0, qtyMax));
          const y = yFromP(P);
          if(i===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        }
        ctx.stroke();
      }

      // Demand: Qd = Ad - Bd*P
      // If Bd=0 => vertical line at Q=Ad (draw as vertical)
      if(Bd === 0){
        ctx.strokeStyle = '#d64545';
        ctx.lineWidth = 3;
        const x = xFromQ(clamp(Ad, 0, qtyMax));
        ctx.beginPath();
        ctx.moveTo(x, yFromP(0));
        ctx.lineTo(x, yFromP(priceMax));
        ctx.stroke();
      } else {
        drawCurve((P)=> (Ad - Bd*P), '#d64545');
      }

      // Supply: Qs = As + Bs*P
      // If Bs=0 => vertical line at Q=As
      if(Bs === 0){
        ctx.strokeStyle = '#2a9d8f';
        ctx.lineWidth = 3;
        const x = xFromQ(clamp(As, 0, qtyMax));
        ctx.beginPath();
        ctx.moveTo(x, yFromP(0));
        ctx.lineTo(x, yFromP(priceMax));
        ctx.stroke();
      } else {
        drawCurve((P)=> (As + Bs*P), '#2a9d8f');
      }

      // Legends
      ctx.fillStyle='#d64545'; ctx.fillRect(canvas.width-150, pad-8, 12, 8);
      ctx.fillStyle='#333'; ctx.fillText('Demand', canvas.width-132, pad);
      ctx.fillStyle='#2a9d8f'; ctx.fillRect(canvas.width-150, pad+12, 12, 8);
      ctx.fillStyle='#333'; ctx.fillText('Supply', canvas.width-132, pad+20);

      // Equilibrium marker + dotted tracking lines (if meaningful)
      if(Number.isFinite(P_eq) && Number.isFinite(Q_eq)){
        const xe = xFromQ(Q_eq);
        const ye = yFromP(P_eq);

        // dotted lines
        ctx.save();
        ctx.setLineDash([4,4]);
        ctx.strokeStyle='rgba(0,0,0,0.18)';
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.moveTo(pad, ye); ctx.lineTo(xe, ye);
        ctx.moveTo(xe, pad+h); ctx.lineTo(xe, ye);
        ctx.stroke();
        ctx.restore();

        ctx.fillStyle = 'black';
        ctx.beginPath(); ctx.arc(xe, ye, 5, 0, Math.PI*2); ctx.fill();
        ctx.font = '13px system-ui';
        ctx.fillText('E', xe+8, ye-8);

        // tiny ticks
        ctx.fillStyle='#555'; ctx.font='11px system-ui';
        ctx.fillText(P_eq.toFixed(2), pad-50, ye+4);
        ctx.fillText(Q_eq.toFixed(2), xe-12, pad+h+18);
      } else {
        // No unique equilibrium price
        pcResult.textContent = 'Equilibrium price is undefined when both curves are perfectly inelastic.';
      }

      // Price control line
      const pcP = parseFloat(pcPrice.value);
      pcPriceTag.textContent = 'P = ' + pcP.toFixed(2);

      const mode = pcCeiling.checked ? 'ceiling' : (pcFloor.checked ? 'floor' : 'none');

      if(mode !== 'none'){
        const yLine = yFromP(pcP);

        // draw line with different color
        ctx.save();
        ctx.setLineDash([6,6]);
        ctx.lineWidth = 2;
        ctx.strokeStyle = (mode === 'ceiling') ? 'rgba(255, 170, 0, 0.95)' : 'rgba(30, 140, 90, 0.95)';
        ctx.beginPath();
        ctx.moveTo(pad, yLine);
        ctx.lineTo(pad+w, yLine);
        ctx.stroke();
        ctx.restore();
      }

      // Binding logic (only if equilibrium exists)
      if(Number.isFinite(P_eq) && Number.isFinite(Q_eq)){
        if(mode === 'none'){
          pcResult.textContent = 'None';
        } else {
          const binding = (mode === 'ceiling') ? (pcP < P_eq) : (pcP > P_eq);

          // Compute Qd and Qs at the control price
          const Qd_at = Ad - Bd*pcP;  // if Bd=0, this is Ad
          const Qs_at = As + Bs*pcP;  // if Bs=0, this is As

          if(!binding){
            pcResult.textContent = (mode === 'ceiling')
              ? `Ceiling is non-binding. Market stays at equilibrium.`
              : `Floor is non-binding. Market stays at equilibrium.`;
          } else {
            if(mode === 'ceiling'){
              const shortage = Math.max(0, Qd_at - Qs_at);
              const traded = Qs_at;
              pcResult.textContent = `Binding ceiling. Shortage ≈ ${shortage.toFixed(2)}. Quantity traded limited by supply ≈ ${traded.toFixed(2)}.`;
            } else {
              const surplus = Math.max(0, Qs_at - Qd_at);
              const traded = Qd_at;
              pcResult.textContent = `Binding floor. Surplus ≈ ${surplus.toFixed(2)}. Quantity traded limited by demand ≈ ${traded.toFixed(2)}.`;
            }
          }
        }
      }

      // UI tags for shifts + steepness
      dShiftTag.textContent = d0.toFixed(1);
      sShiftTag.textContent = s0.toFixed(1);
      dSteepTag.textContent = dSteepEl.value;
      sSteepTag.textContent = sSteepEl.value;
    }

    // Events
    [dInterceptEl, sInterceptEl, dSteepEl, sSteepEl, pcPrice, pcNone, pcCeiling, pcFloor].forEach(el=>{
      el.addEventListener('input', draw);
      el.addEventListener('change', draw);
    });

    draw();
  </script>
</body>
</html>
